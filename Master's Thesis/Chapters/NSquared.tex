\chapter{\todo{The NSquared algorithm}}
Goddard et. al.\cite{nsquared} describes a $O(n^2)$ algorithm for finding the largest agreement subtree for two rooted binary trees. Given two trees T and U of size m and n, the idea is to iteratively find the largest agreement subtree and its size for every pair of subtrees from T and U. This can be done in quadratic time by using Lemma 1. 

\begin{Lemma}
	Let $T_a$ be a tree rooted at vertex a with the children b and c; And let $T_w$ be rooted at w with children x and y. We now define $\#(T_a,T_x)$ as the size of the maximum agreement subtree of $T_a$ and $T_w$.  $\#(T_a,T_x)$ is given by the maximum of the following six numbers: \#$(T_b,T_x)+(T_c,T_y)$,
	\#$(T_b,T_y)+(T_c,T_x)$,
	\#$(T_a,T_x)$,
	\#$(T_a,T_y)$,
	\#$(T_b,T_w)$,
	\#$(T_c,T_w)$
\end{Lemma}

What Lemma 1 essentially states is twofold. First, if the MAST contains children from all subtrees (a,b,x,y), then its size is given by the largest combination of these. Secondly, if the MAST does not include all subtrees, then its size is given by the largest combination of subtrees excluding at least one of them.    
This gives rise to a recursive solution to finding the size of the maximum agreement subtree. The recursive function is defined as follows: 

\begin{equation}
\begin{aligned}
f(T_a,T_w)=Max
\begin{cases}
f(T_b,T_x)+f(T_c,T_y) & \text{if Type($T_a$)=Type($T_w$)=Internal Node}
\\
f(T_b,T_y)+f(T_c,T_x) & \text{if Type($T_a$)=Type($T_w$)=Internal Node}
\\
f(T_a, T_x)           & \text{if Type($T_w$)=Internal Node}
\\
f(T_a, T_y)           & \text{if Type($T_w$)=Internal Node}
\\
f(T_b, T_w)           & \text{if Type($T_a$)=Internal Node}
\\
f(T_c, T_w)           & \text{if Type($T_a$)=Internal Node}
\\
1 	                  & \text{if Type($T_a$)=Type($T_w$)=Leaf  $\land$  $T_a$=$T_w$}
\\
0                     
\end{cases}
\end{aligned}
\phantom{\hspace{6cm}}
\end{equation}
\\
Like many similar recursive definitions in bioinformatics, we run into the problem that the recursive function computes the same partial results multiple times. This problem is rectified by the method of dynamic programming. Specifically, we wish to store the partial results in a $|T_a| \times |T_w|$ table. We seek to fill out the table with our partial results, and end up with the maximum size in the bottom right corner - \todo{\dots} see Figure X.
Looking at (3.1) we see that the partial result for each tree node is dependent on the results of its children. This implies that we must list the table nodes in postorder, thereby ensuring that the partial results, on which a given node is dependent, has already been calculated when we reach it. 
By introducing such a table we also introduce a requirement of $O(n^2)$ space and time, making it a quadratic algorithm. 
\\
We will in the following section show how we extend this method for calculation the size of the MAST to computing the actual tree.

\subsection{Algorithm example}

\begin{figure}
	
	\begin{itemize}
		\item[] a. \Tree [.A [.B [.C leaf_1 leaf_2 ] [.D leaf_3 leaf_4 ] ].B [.E [.F leaf_5 leaf_6 ] [.G leaf_7 leaf_8 ] ].E ].A
		
		b. \Tree [.H [.I [.J leaf_1  leaf_8 ] [.L leaf_5 leaf_6 ] ].I [.M [.N leaf_2 leaf_7 ] [.F leaf_3 leaf_4 ] ].M ].H
	\end{itemize}	
	
	\caption{Two example binary trees for MAST comparison}	
\end{figure}


\subsection{Computing the MAST}

\begin{table}[]
	\centering
	\caption{My caption}
	\label{my-label}
	\begin{tabular}{|c|c|c|c|c|c|c|c|}
		\hline
		\textbf{}        & \textbf{leaf\_1} & \textbf{leaf\_2} & \textbf{C} & \textbf{.....} & \textbf{G} & \textbf{E} & \textbf{A} \\ \hline
		\textbf{leaf\_1} & 1                & 0                & 1          & ...            & 0          & 0          & 1          \\ \hline
		\textbf{leaf\_8} & 0                & 0                & 0          & ...            & 1          & 1          & 1          \\ \hline
		\textbf{J}       & 1                & 0                & 1          & ...            & 1          & 1          & 2          \\ \hline
		\textbf{...}     & ...              & ...              & ...        & ...            & ...        & ...        & ...        \\ \hline
		\textbf{F}       & 0                & 0                & 0          & ...            & 0          & 0          & 2          \\ \hline
		\textbf{M}       & 0                & 1                & 1          & ...            & 1          & 1          & 3          \\ \hline
		\textbf{H}       & 1                & 1                & 2          & ...            & 2          & 3          & 6          \\ \hline
	\end{tabular}
\end{table}


\todo{\dots}

\section{Implementation}
We implemented the algorithm in java (using the forrester \cite{?} library to represent the trees?). We computed the agreement subtrees for each pair of subtrees in the two trees by doing a postorder traversal of the first tree and for each node did a postorder traversal of the second tree. For each pair of nodes $a$ and $w$ we computed the agreement subtree $A_{a,w}$ for the two subtrees $T_a$ and $T_w$ having respectively $a$ and $w$ as roots. For such a pair of nodes there are three cases.

The first case is that $a$ and $w$ are both leaves. If the leaves are equal, i.e. they have the same name, then $A_{a,w}$ will be the tree consisting of exactly one leaf with that name. Otherwise $A_{a,w}$ is empty.

The second case is that we have a leaf and an internal node. Let's say $w$ is the internal node having $x$ and $y$ as children. If the leaf corresponding to $a$ is contained in $T_w$, it will also be contained in either $T_x$ or $T_y$ and $A_{a,w}$ will be the same as either $A_{a,x}$ or $A_{a,y}$. Since we do a postorder traversal of the trees, $A_{a,x}$ and $A_{a,y}$ have already been computed and $A_{a,w}$ can just be set to the largest of the two.

The third case is that both $a$ and $w$ are internal nodes, where $a$ have children $b$ and $c$ and $w$ have children $x$ and $y$. In this case we can use Lemma 1. Again, all the agreement subtrees to consider have already been computed. If the largest subtree is either $A_{b,x} + A_{c,y}$ or $A_{b,y} + A_{c,x}$, $A_{a,w}$ will be the tree having the two subtrees as children.

All these agreement subtrees were stored in a matrix together with their sizes. The last cell in the matrix would then at the end contain the agreement subtree for the two input trees.
\\
\\
How did we verify the algorithm? E.g. bruteforce MAST and compare results.

Show trees and MAST outputted by the program.

\todo{\dots}