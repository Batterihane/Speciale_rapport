\chapter{The NLogN algorithm}

\section{The Base Case}
The base case for finding the maximum agreement subtree of two trees $T_1$ and $T_2$ is when the internal nodes of each tree form a single path through its tree. In this case the maximum agreement subtree can be computed, by using a modified version of the $O(nlogn)$ solution to the Longest Increasing Subsequence (LIS) Problem. We will first describe the $O(nlogn)$ solution the the LIS problem and afterwards describe how we modified it to help us find the MAST of $T_1$ and $T_2$.

\subsection{Solving the Longest Increasing Subsequence Problem}
Given a list $L$ of integers, we want to compute the longest increasing subsequence of integers from that list.

\todo{reference Bespamyatnikh or Knuth?}

The idea of this solution is to compute a list $I$ where the last index holds the smallest integer that ends a longest increasing subsequence of $L$. By having each number point to the number which was previous to it in $I$ when it was added (we will refer to this number as the parent), the LIS can be constructed by iterating through these pointers starting from the last number in $I$.

The procedure is as follows:

\begin{itemize}
	\item Initialize list $I$ and add the first number of $L$.
	\item For every other number $x$ in $L$ do the following:
	\subitem If $x$ is greater than the last number of $I$, add $x$ to the end of $I$.
	\subitem Otherwise, find the smallest number in $I$ which is greater than $x$ and replace it with $x$. This number can be found in $O(logn)$ time using binary search.
	\item Construct the list $LIS$.
	\subitem The last number of $LIS$ is the last number $x$ of $I$.
	\subitem The second last number is the parent $x'$ of $x$.
	\subitem The third last number is the parent of $x'$.
	\subitem ...
\end{itemize}

\subsection{The Modified Longest Increasing Subsequence Problem}
Having the two trees $T_1$ and $T_2$, we can number the leaves of $T_1$ top to bottom, where the ordering of the bottommost two leaves is arbitrary, and number the leaves of $T_2$ such that twins have the same number. This can be done in linear time since each leaf of $T_1$ has a pointer to its twin. By iterating through the leaves of $T_2$ top to bottom, again the ordering of the bottommost two leaves is arbitrary, we get a list $L$ of possibly non-increasing numbers. Since all internal nodes except from the bottommost have exactly one leaf as a child and the numbers of the leaves in $T_1$ are increasing top to bottom, we can construct a MAST from the two trees by finding the longest increasing subsequence of $L$ where the last number need only be greater than the third last number. Since the ordering of the bottommost two leaves of the result doesn't change the topology of the tree, the ordering of the last two numbers of the LIS shouldn't change the result either.

This gives rise to our modified version of the Longest Increasing Subsequence Problem (MLIS):

Given a list $L$ of integers, we want to compute the longest increasing subsequence of integers from that list, but where the last integer only needs to be greater than the third last.

Our solution to this problem is just a modification to the solution described in the previous section.

The list $I$ is constructed similarly, but the last number of $I$ might not be greater than the previous number. Besides having a parent, the last number $x$ of $I$ will also have a pointer to the number which preceded the parent when $x$ was added to $I$ (We will refer to this number as the grandparent of $x$).

Initially, the first two numbers of $L$ is added to $I$. For every other number $x$ in $L$ there are 2 cases:

\begin{itemize}
	\item Case 1: The last number $y$ of $I$ is greater than its parent $p(y)$.
	\subitem If $x > p(y)$, then $x$ is added at the end of $I$.
	\subitem Otherwise, find the smallest number in $I$ which is greater than $x$ and replace it with $x$.
	\item Case 2: The last number $y$ of $I$ is smaller than its parent.
	\subitem If $x$ is greater than one of the two last numbers of $I$, $y$ and $y'$, then $x$ is put at the last index and the smallest of $y$ and $y'$ at the second last.
	\subsubitem If $y < y'$, then the parent of $y$ is updated so that it now points to its grandparent.
	\subitem Otherwise, find the smallest number in $I$ which is greater than $x$ and replace it with $x$.
\end{itemize}

\todo{explain each case?}

\section{Centroid decompositions}
The first step of the algorithm is to compute the \texttt{Centroid decomposition}s for the two trees. A centroid decomposition consists of an amount of disjoint paths through the tree, called \texttt{Centroid path}s. Such a path starts at a node in the tree and contains the edge to the child node holding the largest amount of leaves in its subtree. In case of a tie, an arbitrary edge is picked. The path will continue until reaching a leaf.

For the first tree, the centroid decomposition consists of only the centroid path starting at the root. We will refer to this path as $\pi$ having the nodes $u_1$ to $u_p$ from root to leaf. For the second tree, the centroid decomposition consists of all possible disjoint centroid paths. These paths will be referred to as $\pi(x)$, having nodes $v_1$ to $v_q$ from start node to leaf, where $x$ is the start node, which is the node on the path closest to the root.

The implementation of this principle was done by storing the number of leaves in the subtree of a node at each node in the two trees such that this number could be looked up in constant time. Now for the centroid decomposition of the first tree, we simply started at the root node and picked the edge to the node with the highest number stored. For the second tree, the same thing was done, but when picking the edge to a child node, we also started another path at the second child if it wasn't a leaf.

\section{Induced subtrees of $T_2$}
The centroid decomposition of the main algorithm splits $T_1$ into a forest of subtrees $M_i$, $1 \le i \le p-1$. We are in the second step of the algorithm required to determine the subtrees $S_i$ of $T_2$ induced by the leaves of each $M_i$.
We will now show how each of these can be computed linear time with respect to the number of leaves in the subtree, provided that $T_2$ has been preprocessed in linear time.

\subsection{Preprocessing $T_2$}
To induce subtrees in linear time, two requirements must be met. The Least Common Ancestor (LCA) between two leaves should be computed in constant time, and the depth of each vertex in the tree must be known. Both of these requirements can be achieved in linear time with respect to the size of the tree. 
\\
The vertex depth can be found in linear time by a simple pre-order tree traversal (REF?), where each node sets its children's depth to it's own depth+1. The depth of the root is initializes to zero.  
\\
Computing LCA in $O(1)$ is a tricky affair, and is covered in Section/Chapter ??

\subsection{Inducing the subtree}
We are given a tree and an ordered set of leaves, $L=l_1,l_2,l_3,...,l_n$ ,and must find the subtree induced by this set. The algorithm works in 3 steps:
\begin{enumerate}
	\item Find the LCA of each consecutive pair of leaves such that $A_i=LCA(l_i,l_i+1), where 1 \le i \le n-1$, and add them correspondingly to $L$. ($L$ now contains all vertices in the subtree)
	\item For each vertex $V$ in $L$, find the closest vertex on either side, $V_l$ and $V_r$, that has smaller depth than itself.
	\item The parent of vertex $V$ will be whichever of $V_l$ and $V_r$ that has the greatest depth.
\end{enumerate}

The challenge of implementing this algorithm was to perform step 2 in linear time. We did this by realizing that for the vertices of greatest depth, $V_l$ and $V_r$ would always be the vertices immediately to the left and right in the set (because of the way the LCAs were added to the set). By removing these vertices from the set, the same would now be the case for the vertices of second greatest depth and so forth. This resulted in the following approach for step 2 of the algorithm:
\begin{enumerate}
	\item For each vertex in the set, add its index number to a set $D_i$ corresponding to its depth.
	\item Create a new set $S$ of length n, where each cell block points to the previous and the subsequent cell. (each cell corresponds to a vertex)
	\item For each number in the depth sets, starting at the one with greatest depth, lookup the corresponding cell $s_i$ in $S$ and update the cells it points to, so that they no longer point to $s_i$, but instead points to each other. ($s_i$ is "removed" from the set).
	\item Cell $s_i$ in $S$ now corresponds to vertex $V$ with index $i$ in $L$. $V_l$ and $V_r$ corresponds to the vertices at the indices pointed to by $s_i$.
\end{enumerate}

\subsection{Computing the induced subtrees of $T_2$}
Now that we can induce a subtree from a set of leaves in linear time, all we need is to find the leaves from which we can induce the subtree $S_i$ of $T_2$, given the subtree $M_i$ of $T_1$. Our approach to this is slightly different from the one explained in \cite{nlogn} \todo{explain why}. First we wanted the names of all leaves to be numbers (from 0 to n-1). This is done when creating the tree structures from the newick files?? which was/is explained in \todo{section/chapter ???}. Second, for each leaf in $T_1$ we wanted it to be possible to find its twin in $T_2$ in constant time. By storing a list for each tree of all its leaves, where each leaf is at the index corresponding to its name, the twin of a leaf named $i$ from $T_1$ can be looked up in constant time from the list for $T_2$ at index $i$.

In order to induce subtree $S_i$, the input leaves needs to be sorted by the order that they appear in $T_2$. Our approach to this was to first compute a sorted list of all leaves in $T_1$ according to $T_2$, then splitting the leaves into lists corresponding to the subtrees $M_i$, $1 \le i \le p-1$ and finally use their twins to induce the subtree $S_i$ for each list.

The leaves of $T_1$ was sorted by first giving each leaf of $T_2$ a number corresponding to its position (left to right) in $T_2$. This was done by iterating through $T_2$. Then sorting the leaves from $T_1$, by looking up the number of its twin in $T_2$, in linear time using bucket sort.
For the input trees, the leaves of $T_1$ could also be sorted by their name, assuming that the names of $T_2$ where sorted. However, in the recursive calls the names will no longer correspond to the number of leaves, which is why we instead assign numbers the leaves of $T_2$.

% First try
% Creating a list, where index $i$ holds the position, left to right, of the leaf named $i$ in $T_2$ compared to the other leaves, is done in linear time simply by iterating through $T_2$. That list is used when sorting the leaves of $T_1$ to look up the position of the twins in $T_2$. We sort the leaves in linear time using bucket sort.

By iterating through each subtree $M_i$, we can use linear time to have each leaf store a number corresponding to the subtree to which it belongs. Having the sorted list of leaves in $T_1$, we can use the stored numbers to split the leaves into the final lists during a single iteration. Now the twins can be found and the subtrees $S_i$, $1 \le i \le p-1$ can be computed.

All in all this process takes linear time, w.r.t. the number of leaves.

In the implementation, $S_i$ will not actually consist of nodes from $T_2$. It is a new tree where each node contains a reference to the corresponding node in $T_2$ and vice versa.

\section{Constructing MASTs recursively}
When having computed the $S_i$ subtrees, we can construct the MASTs for each pair $(M_i, S_i)$, $1 \le i \le p-1$. This is done recursively, where $M_i$ becomes $T_1$ and $S_i$ becomes $T_2$. The twin pointers are transferred such that each leaf of $M_i$ points to its twin in $S_i$. % When constructing S_i, we add a pointer from the leaves in T_2 to the corresponding leaves in S_i. When constructing leaf m of M_i, we can get the twin of the corresponding leaf in T_1 and find the leaf that it points to in S_i. This should be the twin of m.
After having constructed the MAST for $M_i$ and $S_i$, each node $w$ of $S_i$ should hold the size of the MAST for $M_i$ and the subtree $S_i(w)$. 

\section{Matching Graphs}
The next step of the algorithm is to compute the matching graphs. A graph is created for each path in the centroid decomposition for $T_2$, in order bottom to top. Such a graph consists of an amount of edges between two nodes.

Let $x$ be the start node of the centroid path $\pi(x)$ in $T_2$ with side trees $N_j, 1 \le j \le q$. Then the graph $G(x)$ is defined as follows:

\begin{itemize}
	\item $G(x)$ consists of edges between two sets of nodes $L(x)$ and $R(x)$.
	\item $R(x)$ consists of the nodes from $\pi(x)$.
	\item $L(x)$ contains nodes from the centroid path $\pi$ in $T_1$, for which there is an edge to some node in $R(x)$.
	\item The nodes of each set are in the order that they appear in the path that they are created from. I.e. the topmost node of a set is the node closest to the root and the bottommost is the one farthest from the root.
	\item An edge $(u_i, v_j), 1 \le i \le p-1, 1 \le j \le q$ exists if and only if $S_i \cap N_j \ne \emptyset$
	\item An edge $(u_p, v_j), 1 \le j \le q$ exists if the twin of $u_p$ is in $N_j$.
\end{itemize}

A matching graph $G(x)$ is used to create a Largest Weight Agreement Matching (LWAM) which can be translated directly to the MAST of $T_1$ and $T_2(x)$. The LWAM is found by computing the LWAM containing only edges from $u_i$ and nodes below $u_i$ in $L(x)$, for each $u_i \in L(x)$, starting from the bottom. This will be covered in detail in \todo{section ??}.

\subsection{Creating the Matching Graphs}
First of all, a graph is created for each centroid path in $T_2$, where all nodes in the path is added to the right set. In order to get access to such a graph in constant time from a node in the path, we will make each start node of the paths point to the corresponding graph.
Since the left set of each graph only contains nodes from $\pi$ we can add these nodes and all edges by doing a walk through $\pi$. This walkthrough contains the following steps for each node $z \in S_i$ for each $u_i \in \pi, 1 \le i \le p-1$:

\begin{enumerate}
	\item Find the corresponding node $z'$ in $T_2$.
	\item If $z'$ is on a centroid path $\pi(z')$ (this is the case if $z'$ has a pointer to the start node of a path), do the following:
	\subitem Find the graph $G(z')$ that corresponds to the path $\pi(z')$. This is done in linear time since $z'$ has a pointer to the start node $start(\pi(z'))$ which has a pointer to the graph.
	\subitem Add $u_i$ to $L(z')$ if it has not already been added.
	\subitem Add an edge between $u_i$ and $z'$ in $G(z')$.
	\subitem Repeat from step 1 using the parent of $start(\pi(z'))$ as node $z$.
	\item If $z'$ is not on a centroid path, repeat from step 1 using the parent of $z$.
\end{enumerate}
The loop stops either when reaching the root of $T_2$ or when reaching a node which is on the same path as the node in $T_2$ that corresponds to the parent of $z$ in $S_i$. The second case means that the rest of the processing has already been done by the parent. This ensures that for each node visited in $T_2$, an edge is added to some graph, meaning that the process of adding all edges takes linear time with respect to the total number of edges in the graphs.

For the last node $u_p$ in $\pi$, the process is very similar. $z$ starts being the twin of $u_p$ and the loop continues until reaching the root of $T_2$.\\

For a node $s$ in a subtree $S_i, 1 \le i \le p-1$, every node $v_j$ visited in the iteration, will be the node that is the closest ancestor of $s$ in some path, which means that either $s \in N_j$ or $s=v_j$. Both cases means that $S_i \cap N_j \ne \emptyset$ so an edge should be added.

\subsection{Edge Weights}
Each edge in a graph is a multiedge consisting of a white, green and red edge, each with its own weight. The weights are defined as follows:
\begin{itemize}
	\item White edge weight: $weight_w(u_i, v_j)=$ size of $MAST(M_i,N_j)$
	\item Green edge weight: $weight_g(u_i, v_j)=$ size of $MAST(M_i,T_2(v_j))$
	\item Red edge weight: $weight_r(u_i, v_j)=$ size of $MAST(T_1(u_i),N_j)$
\end{itemize}

In order to compute the weight of each edge in constant time, a node $map(i,j)$ is defined for the multiedge $(u_i,v_j)$. $map(i,j)$ is the node of $S_i$ which is closest the root and either a descendant of or equal to $v_j$ in $T_2$. The edge $(u_i,v_j)$ is added to a graph during an iteration of a node in $S_i$, as described in the previous section. That node is exactly the node closest to the root in $S_i$ which is also a descendant or equal to $v_j$ in $T_2$, so a reference to $map(i,j)$ is added in constant time.

Recall that at this point in the algorithm, we have already constructed the MAST for $M_i$ and $S_i$, $1 \le i \le p-1$, and that each node $w$ of $S_i$ now holds the size of the MAST for $M_i$ and $S_i(w)$.

First, if one of $u_i$ and $v_j$ is a leaf, then the weight of all three edges is 1. Otherwise, let $y=map(i,j)$.

\subsubsection{White Edge Weight}
$y$ is either a descendant of or equal to $v_j$. In the former case, we know that $y \in N_j$ or the edge would not have been added. So the weight of the white edge is the size of $MAST(M_i, S_i(y))$, which can be looked up in $y$ in constant time. In the latter case, one of $y's$ children is in $N_j$. That child $z$ is then the node closest to the root of $S_i$ which is in $N_j$, so the weight is the size of $MAST(M_i, S_i(z))$, which is looked up in $z$. Since all nodes on a path of $T_2$ has a reference to the topmost node of that path, $z$ can be found in constant time by picking the child of $v_j$ that does not have a reference to the same node as $v_j$, i.e. the root of $N_j$. If that node is the first child of $v_j$, then $z$ is the first child of $y$ and vice versa.

\subsubsection{Green Edge Weight}
The green edge weight is the size of $MAST(M_i,T_2(v_j))$. $S_i(y)$ is the subtree of $T_2(v_j)$ containing only leaves of $M_i$, so the weight is $MAST(M_i, S_i(y))$.

\subsubsection{Red Edge Weight}
Now let $y$ be the root of $N_j$, which we showed how to find in constant time. Since $y$ is a descendant of $x$ and the graphs and LWAMs are computed in order bottom the top, the LWAM of $G(y)$, has already been computed. In that computation, the LWAM containing only edges from $u_i$ and nodes following $u_i$ in $L(y)$ was also computed and translates to the MAST of $T_1(u_i)$ and $N_j$. The red edge weight is the size of that tree. We know that $u_i$ is in $L(y)$ since $M_i$ and $N_j = T_2(y)$ intersects.

\section{Agreement Matchings}
\todo{Describe how to create the agreement matchings}\\
\todo{Describe how and why a LWAM corresponds to a MAST}
\todo{Describe definitions: nsav, ...}

\subsection{Definitions}
We will start by describing some definitions used in agreement matchings.

\subsubsection{Vertices}
For vertices in the graph $G(x)$ we have the following definitions:
\begin{itemize}
	\item $d_x(u_i)$: The 'degree' of a vertex $u_i \in L(x)$ is the number of white edges incident on it.
	\subitem A vertex in $L(x)$ is a 'singleton' vertex if it has degree 1.
	\subitem White edges incident on singleton vertices are called 'singleton' edges.
	\item $nswe(x)$: The number of non-singleton white edges in $G(x)$.
	\item $nsav(x)$: The number of vertices in $R(x)$ having at least one incident non-singleton edge.
	\item $SV(x)$: The set of singleton vertices.
\end{itemize}

\subsubsection{Edges}
For two edges $(a,b)$ and $(a',b')$ in $G(x)$, we will say they 'cross' if $a$ is above $a'$ in $L(x)$ and $b$ is below $b'$ in $R(x)$. The two edges 'touch' if they are either crossing or $a=a'$ or $b=b'$. Finally $(a,b)$ 'dominates' $(a',b')$ if $a$ is above $a'$ and $b$ is above $b'$.

\subsubsection{Agreement Matchings}
In the graph $G(x)$, a 'Proper Crossing' is either a single red edge, a single green edge or a crossing of a red edge $(u_i,v_j)$ and a green edge $(u_i',v_j')$ where $u_i'$ is above $u_i$ in $L(x)$.

Now an agreement matching can be defined as a proper crossing and zero or more white edges, where all white edges dominate the edge(s) in the proper crossing and no white edge touches any other edge in the matching.

\subsection{The Weighted Search Tree}
For each matching graph $G(x)$, we need to create a weight balanced binary search tree $\mathcal{T}$ from the nodes in $R(x)$. Each node $v_j$ will be a leaf in $\mathcal{T}$ with weight $n_j + \frac{|T(x)|}{nsav(x)}$ if a non-singleton edge in $G(x)$ has endpoint in $v_j$ and weight $n_j$ otherwise.

Such a tree can be constructed in $O(|R(x)|)$ time using the following algorithm which is our version of the algorithm described by \todo{[Mehlhorn (, Fredman)]}.

\begin{itemize}
	\item Given weights ${w_0, w_1, ..., w_{n-1}}$, construct two lists of sums ${L_0, ..., L_{n}}$ and ${R_0, ..., R_{n}}$, where
	\subitem $L_j=\sum_{k=0}^{j-1} w_k$, $L_0=0$
	\subitem $R_j=\sum_{k=j}^{n-1} w_k$, $R_{n}=0$
	\item Construct the tree from weights ${w_0, w_1, ..., w_{n-1}}$ by recursion over the following steps:
	\subitem Given weights ${w_i, ..., w_j}$
	\subitem If $i=j+1$ then create node $j$ with children $i$ and $j$.
	\subitem Otherwise, determine the smallest $k, i<k\le j$ such that
	\subsubitem $L_k-L_i \ge R_k-R_{j+1}$
	\subitem Define node $k$ with the children created recursively from weights
	\subsubitem ${w_i, ..., w_{k-1}}$ and ${w_k, ..., w_j}$
	\subsubitem If $i=k-1$, the left child is just node $i$
	\subsubitem If $k=j$, the right child is just node $j$
\end{itemize}

Determining $k$ from the weights ${w_i, ..., w_j}$ is done by finding the smallest $k$ satisfying $L_k-L_i \ge R_k-R_{j+1}$. This can be done in time $O(log(k))$ as follows:

\begin{itemize}
	\item For the middle index $k=i+(j-i+1)/2$, determine whether $L_k-L_i \ge R_k-R_{j+1}$
	\item If not, let $k=i+1, k=i+2, k=i+4, k=i+8$ until $L_k-L_i \ge R_k-R_{j+1}$
	\subitem In the interval between $k$ and the previous value of $k$, use binary search to find the smallest $k$ satisfying $L_k-L_i \ge R_k-R_{j+1}$
	\item The case where $L_k-L_i \ge R_k-R_{j+1}$ is treated symmetrically
\end{itemize}

Our implementation of this algorithm was done iteratively, but the approach was the same.

In the final tree, each node $v$ will hold an index number $index(v)$. Searching for the leaf created from $v_j$, with index number $i$, in $\mathcal{T}$ takes $O(log \dfrac{|T(x)|}{n_j}$ time \todo{explain why} and is done in the standard way by starting at the root and picking the left child if $i < the current node index$, and the right child otherwise until reaching the desired leaf. Each node $v$ will also hold the lowest index number $low(v)$ and largest index number $high(v)$ in its subtree, which is used when searching for an ordered subset of $R(x)$. These numbers are added while creating the tree. For the root $r$, $low(r)$ is 0 and $high(r)$ is $|R(x)|-1$. For a left child $v$, $low(v)=low(parent(v))$ and $high(v)=index(parent(v))-1$. For a right child $v$, $low(v)=index(parent(v))$ and $high(v)=high(parent(v))$.

Given the subset ${v_i, ..., v_j}$ of $R(x)$ in bottom to top order, let ${index(v_i), ..., index(v_j)}$ be the corresponding indices. Searching for the leaves with these indices in $\mathcal{T}$ is done by first searching for the leaf $l$ with index $index(v_i)$ in the standard way. Then search for the leaf with index $index(v_{i+1)}$ by starting at $l$ and go up through the tree until reaching a node whose lowest index number is less than $index(v_{i+1)}$. The leaf with index $index(v_{i+1)}$ is now found by searching in the standard way starting at the node just reached. This procedure takes $O(k*log \dfrac{nsav(x)}{k})$ time \todo{explain why}. Given a subset of $R(x)$ in top to bottom order, searching for the corresponding leaves in $\mathcal{T}$ is done similarly, but using the largest index numbers instead of the lowest.

\subsection{Computing the Largest Weight Agreement Matchings}
Computing the LWAM for the graph $G(x)$ is done by processing each node of $L(x)$ in order starting with the bottom node. For each node $u_i \in L(x)$, we process each edge incident on it. Recall that we will compute the LWAM containing only edges from $u_i$ and nodes below $u_i$ in $L(x)$, for each $u_i \in L(x)$. This is done by maintaining all that information in $\mathcal{T}$ while processing the nodes of $L(x)$.

\subsubsection{Auxiliary Information in $\mathcal{T}$}
While processing the edges of $G(x)$ we will maintain information at each node of $\mathcal{T}$ about the LWAM of the currently processed edges. For a node $z \in \mathcal{T}$, we define $anc(z)$ as the set of ancestors of $z$, including $z$ itself in order top to bottom. $lfringe(z)$ is defined as the left children of the vertices in $anc(z)$ which are not in $anc(z)$ themselves. $lfringe$ will only contain nodes with indices less than $index(z)$. $rfringe(z)$ is defined analogously where the nodes all have indices greater or equal to $index(z)$. $anc(z)$ need not be stored in $\mathcal{T}$, but can be created while searching for $z$ in $\mathcal{T}$. Likewise, $lfringe(z)$ and $rfringe(z)$ can be created by iterating through $anc(z)$. After processing an edge $(u,v)$, we say that the edge is in $\mathcal{T}$. For a node $z \in \mathcal{T}$ we also say that $(u,v)$ is in $T(z)$ if $T(z)$ contains the node corresponding to $v$.

The following information is maintained at each vertex $z \in \mathcal{T}$. This is taken directly from \citeA{nlogn}, but slightly elaborated.
\begin{itemize}
	\item $g(z)$: After updating $g(z)$, it will hold the heaviest green edge in $\mathcal{T}$ which	forms a proper crossing with each red edge in $\mathcal{T}(z)$.
	\subitem However, $g(z)$ is not maintained at all times, but the correct edge can be retrieved from $max_{z' \in anc(z)}g(z')$.
	\subitem If there are no red edges in $\mathcal{T}(z)$ when updating $g(z)$, then $g(z)$ will be the heaviest green edge in $\mathcal{T}(z')$, for all $z' \in rfringe(z)$.
	\item $x(z)$: This is the largest weight proper crossing, that is not a single red edge, among the edges in $\mathcal{T}(z)$.
	\item $m(z)$: This is largest weight agreement matching containing a white edge
	such that the topmost white edge is in $\mathcal{T}(z)$.
	\item $y(z)$: This the largest weight proper crossing, which is not a single edge, such that the green edge is in $\mathcal{T}$ but not in $\mathcal{T}(z)$, the red edge is in $\mathcal{T}(z)$, and the green edge does not form a proper crossing with all the red edges in $\mathcal{T}(z)$.
	\item $r(z)$: This is simply the heaviest red edge in $\mathcal{T}(z)$.
\end{itemize}

In the following, we will explain how each colour edge is processed. Let $e=(u_i,v_j)$ be the edge in $G(x)$ that should be processed and $l$ be the leaf in $\mathcal{T}$ corresponding to $v_j$. We know that all edges incident on nodes below $u_i$ in $L(x)$ have already been processed.

\subsubsection{Processing white edges}
The only values that might change in $\mathcal{T}$ is $m(z), z \in anc(l)$. First, $anc(l)$ is found while searching for $l$ in $\mathcal{T}$. Now the LWAM with $e$ as topmost edge needs to be determined. This is done by finding the LWAM containing only edges dominated by $e$ and then adding $e$ as the topmost white edge. Since the nodes of $L(x)$ are processed starting from the bottom, we know that $\mathcal{T}$ does not contain any edges incident on nodes above $u_i$ in $L(x)$. The subtrees of nodes in $rfringe(l)$ contains exactly the edges in $\mathcal{T}$ only incident on nodes below $v_j$ in $R(x)$. By the order we process the edges, we also make sure that the edges from $u_i$ are processed such that $rfringe(l)$ contains no edge incident on $u_i$. There are four cases of LWAMs:
\begin{itemize}
	\item The LWAM contains one or more white edges.
	\subitem This matching is given by $max_{z \in rfringe(l)} m(z)$
	\item The LWAM is a single green edge or a green-red crossing where both edges are in the subtree $\mathcal{T}(z)$ for some $z \in rfringe(l)$.
	\subitem This matching is given by $max_{z \in rfringe(l)} x(z)$
	\item The LWAM is a single red edge or a green-red crossing where the red edge is in the subtree $\mathcal{T}(z)$ for some $z \in rfringe(l)$. The green edge forms a proper crossing with all red edges in $\mathcal{T}(z)$.
	\subitem This matching is given by $max_{z \in rfringe(l)} (max_{z' \in anc(z)} g(z')) + r(z)$
	\item The LWAM is a green-red crossing where the red edge is in the subtree $\mathcal{T}(z)$ for some $z \in rfringe(l)$. The green edge is not in $\mathcal{T}(z)$ and does not for a proper crossing with all red edges in $\mathcal{T}(z)$.
	This matching is given by $max_{z \in rfringe(l)} y(z)$
\end{itemize}

These cases cover all possible LWAMs, so the LWAM containing only edges incident on nodes below $u_i$ in $L(x)$ and nodes below $v_j$ in $R(x)$ must be the largest.

\subsubsection{Processing red edges}
The values that might change in $\mathcal{T}$ when adding a red edge is $y(z), g(z)$ and $r(z), z \in anc(l)$. Since none of the green edges in $\mathcal{T}$ can form a proper crossing with $e$, $y(z)$ might change for $z \in anc(l)$. So $y(z)$ is updated to $max{y(z), (max_{z' \in anc(z)} g(z')) + r(z)}$. Now $g(z)$ should be reset for all $z \in anc(l)$. However, in order to maintain all $g$ values in $\mathcal{T}$, $g(y)$ needs to be updated to $max_{y' \in anc(y)} g(y')$ for each $y \in lfringe(l)$ and $y \in rfringe(l)$ before resetting. Finally, $r(z)$ need to be updated for $z \in anc(l)$ if the weight $wt(e)$ of the new edge is greater than that the current value of $r(z)$. $r(z)=max{r(z), wt(e)}$.

\subsubsection{Processing green edges}
Adding a green edge to $\mathcal{T}$ might change the values $g(z), z \in lfringe(l)$ and $x(z), z \in anc(l)$. When adding the green edge $e$, it will form proper crossings with all red edges in $\mathcal{T}$ incident on nodes in $R(x)$ above $v_j$. This is true since each red edge in $\mathcal{T}$ is either incident on a node in $L(x)$ below $u_i$ or is incident on both $u_i$ and $v_j$. This is guaranteed by the processing order of the edges. Therefore $g(z), z \in lfringe(l)$ is updated to $e$ if the weight $wt(e)$ of $e$ is greater than that of the currently heaviest green edge forming a proper crossing with all red edges in $\mathcal{T}(z)$. $g(z)=max{wt(e), max_{z' \in anc(z)} g(z')}, z \in lfringe(l)$. The value $x(z), z \in anc(l)$ might also need to be updated if the proper crossing between $e$ and a red edge in $\mathcal{T}(z)$ is heavier than the current value of $x(z)$. $x(z)=max{x(z), wt(e) + max(r(z'))}, z \in anc(l)$. Here $max(r(z'))$ maximizes over the vertices $z' \in lfringe(l)$ which are descendants of $z$.

\subsubsection{Processing order}
Recall that we process the edges by iterating through $L(x)$ starting from the bottommost node, and process the edges incident on each of these nodes. For a node $u_i \in L(x)$ we will start by processing the white edges incident on $u_i$ in order, starting from the topmost edge, i.e. the edge incident on the topmost node in $R(x)$. Starting with the white edges in top-down order means that when processing the white edge $e=(u_i,v_j)$, no other edge incident on $u_i$ below $e$ has been processed.

Next, we process the red and green edges incident on $u_i$ in order, starting from the bottommost edge. This ensures that when processing a green edge $e=(u_i,v_j)$, no red edges incident on $u_i$ and above e has been processed.

\subsubsection{Extracting the Largest Weight Agreement Matchings}
First, we need to compute the LWAM containing only edges from $u_i$ and nodes below $u_i$ in $L(x)$, for each $u_i \in L(x)$. For any $u_i \in L(x)$, all the information needed to compute such a matching is stored at the root $r$ of $\mathcal{T}$ after having processed the edges incident on $u_i$ and before processing edges incident on the above nodes in $L(x)$. The LWAM is extracted in the following way:

If the LWAM contains a white edge it is simply given by $m(r)$. If the LWAM is a proper crossing, but not a single red edge, it is given by $x(r)$. And finally, if the LWAM is a single red edge, it is given by $r(r)$. Therefore the LWAM is the heaviest of these three matchings.

For each $v_j \in R(x)$, we also need to compute the LWAM containing only edges incident on $v_j$ and nodes below $v_j$ in $R(x)$. For leaf $v_j \in R(x)$, such a matching will correspond to the MAST between $T_1$ and $T_2(v_j)$ which is the MAST that needs to be stored at $v_j \in T_2$. The LWAMs are extracted from $\mathcal{T}$, after all edges in $G(x)$ have been processed, in the following way:

For node $v_j \in R(x)$, let $l$ be the leaf in $\mathcal{T}$ corresponding to $v_j$ and let $LWAM(v_j)$ be the LWAM containing only edges incident on $v_j$ and nodes below $v_j$ in $R(x)$. $LWAM(v_j)$ is either equal to $LWAM(v_{j+1}), j \ne |R(x)|$ (-1?), or it is the LWAM having a white edge incident on $v_j$ as the topmost edge, or it is the largest proper crossing having a red edge incident on $v_j$, or it is a single green edge incident on $v_j$. Thus, $LWAM(v_j)$ is given by $max\{LWAM(v_{j+1}), m(l), y(l), max_{z \in anc(l)}g(z) + r(l), x(l)\}$ where $LWAM(v_{|R(x)|+1}) = 0$.

\section{Creating the Maximum Agreement Subtrees}
As mentioned earlier, a Largest Weight Agreement Matching constructed from the matching graph $G(x)$ corresponds to a Maximum Agreement Subtree between $T_1$ and $T_2(x)$. We will show how the MAST $\mathcal{A}$ can be constructed given the LWAM with white edges ${we_0, we_1, ...}$ and proper crossing with edges ${ge, re}$ or single edge $ge$ or $re$.

Recall that a white edge $(u_i, v_j)$ corresponds to the subtree $MAST(M_i,N_j)$, a green edge corresponds to $MAST(M_i,T_2(v_j))$ and a red edge corresponds to $MAST(T_1(u_i),N_j)$. These subtrees will appear in $\mathcal{A}$ in the same order that the edges appear in the matching. $\mathcal{A}$ will have an internal node for each white edge which forms a path ${p_0, p_1, ...}$ through $\mathcal{A}$. These nodes will be in the same order that the white edges appear in the matching. The off-path child of node $p_i$ will then be the root of the subtree corresponding to edge $w_i$. The second off-path child $c$ of the last node in the path will hold the subtree(s) corresponding to the edge(s) in the proper crossing. If the proper crossing is a single edge, $c$ will be the root of the subtree corresponding to that edge. Otherwise $c$ will have two children, one being the root of the subtree corresponding to $ge$ and one being the root of the subtree corresponding to $re$.

What we need now is to find the subtrees corresponding to the edges in the matching. All these subtrees have already been computed and is found in the same way as the edge weight were computed. \todo{store subtrees at edges??}.








