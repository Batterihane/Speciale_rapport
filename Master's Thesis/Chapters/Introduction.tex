\chapter{Introduction}
\label{ch:intro}
The Maximum Agreement Subtree problem (MAST) provides mutual information between rooted trees, and is defined as such: Given two rooted trees, T1 and T2, created over the same leaf-set \{1,2,3...,n\}, determine the largest possible subset of leaves inducing an agreeing subtree of T1 and T2. For a set of leaves to induce an agreeing subtree for T1 and T2, the subtrees restricted to the set of leaves must be isomorphic, implying structural equivalency.
\\

Let us start by motivating the interest in MAST by giving an example of its application. Suppose that we are interested in inspecting the relationship between DNA obtained from different animal species. This is typically done by the use of  Hierachical Clustering (REF) or Neighbor Joining (REF) to construct evolutionary trees. However, finding the true evolutionary tree is often an elusive task, and evidence is required to support any suggested tree topology. Finding the Maximum Agreement Subtree will present the information that both trees agree on, which makes the information more reliable, given that multiple sources support it. 

The MAST problem applies to all trees, but we will choose to focus on the rooted, binary trees given that the motivation for the problem is primarily rooted in biology and linguistics, where these trees are most common. Specifically, we will examine, implement and compare three different algorithms for solving the MAST problem for binary trees in order to clarify strengths and weaknesses of each in theory and in practice.     



The MAST problem is one of several ways of defining tree distances. -which one is superior?


\begin{align*}
	\frac{3x + y}{7} &= 9  && \text{given}   \\
	3x + y &= 63           && \text{multiply by 7}   \\
	3x &= 63 - y           && \text{subtract y}   \\
	x &= 21 - \frac{y}{3}  && \text{divide by 3}   \\
\end{align*}




\begin{algorithm}
	\caption{Naive solution}\label{euclid}
	\begin{algorithmic}[1]
		\Procedure{MyProcedure}{}
		\State $\textit{stringlen} \gets \text{length of }\textit{string}$
		\State $i \gets \textit{patlen}$
		\BState \emph{top}:
		\If {$i > \textit{stringlen}$} \Return false
		\EndIf
		\State $j \gets \textit{patlen}$
		\BState \emph{loop}:
		\If {$\textit{string}(i) = \textit{path}(j)$}
		\State $j \gets j-1$.
		\State $i \gets i-1$.
		\State \textbf{goto} \emph{loop}.
		\State \textbf{close};
		\EndIf
		\State $i \gets i+\max(\textit{delta}_1(\textit{string}(i)),\textit{delta}_2(j))$.
		\State \textbf{goto} \emph{top}.
		\EndProcedure
	\end{algorithmic}
\end{algorithm}


