\chapter{The NLogN algorithm}

\section{Centroid decompositions}
The first step of the algorithm is to compute the \texttt{Centroid decomposition}s for the two trees. A centroid decomposition consists of an amount of disjoint paths through the tree, called \texttt{Centroid path}s. Such a path starts at a node in the tree and contains the edge to the child node holding the largest amount of leaves in its subtree. In case of a tie, an arbitrary edge is picked. The path will continue until reaching a leaf.

For the first tree, the centroid decomposition consists of only the centroid path starting at the root. We will refer to this path as $\pi$ having the nodes $u_1$ to $u_p$ from root to leaf. For the second tree, the centroid decomposition consists of all possible disjoint centroid paths. These paths will be referred to as $\pi(x)$, having nodes $v_1$ to $v_q$ from start node to leaf, where $x$ is the start node, which is the node on the path closest to the root.

The implementation of this principle was done by storing the number of leaves in the subtree of a node at each node in the two trees such that this number could be looked up in constant time. Now for the centroid decomposition of the first tree, we simply started at the root node and picked the edge to the node with the highest number stored. For the second tree, the same thing was done, but when picking the edge to a child node, we also started another path at the second child if it wasn't a leaf.

\section{Induced subtrees of $T_2$}
The centroid decomposition of the main algorithm splits $T_1$ into a forest of subtrees $M_i$, $1 \le i \le p-1$. We are in the second step of the algorithm required to determine the subtrees $S_i$ of $T_2$ induced by the leaves of each $M_i$.
We will now show how each of these can be computed linear time with respect to the number of leaves in the subtree, provided that $T_2$ has been preprocessed in linear time.

\subsection{Preprocessing $T_2$}
To induce subtrees in linear time, two requirements must be met. The Least Common Ancestor (LCA) between two leaves should be computed in constant time, and the depth of each vertex in the tree must be known. Both of these requirements can be achieved in linear time with respect to the size of the tree. 
\\
The vertex depth can be found in linear time by a simple pre-order tree traversal (REF?), where each node sets its children's depth to it's own depth+1. The depth of the root is initializes to zero.  
\\
Computing LCA in $O(1)$ is a tricky affair, and is covered in Section/Chapter ??

\subsection{Inducing the subtree}
We are given a tree and an ordered set of leaves, $L=l_1,l_2,l_3,...,l_n$ ,and must find the subtree induced by this set. The algorithm works in 3 steps:
\begin{enumerate}
	\item Find the LCA of each consecutive pair of leaves such that $A_i=LCA(l_i,l_i+1), where 1 \le i \le n-1$, and add them correspondingly to $L$. ($L$ now contains all vertices in the subtree)
	\item For each vertex $V$ in $L$, find the closest vertex on either side, $V_l$ and $V_r$, that has smaller depth than itself.
	\item The parent of vertex $V$ will be whichever of $V_l$ and $V_r$ that has the greatest depth.
\end{enumerate}

The challenge of implementing this algorithm was to perform step 2 in linear time. We did this by realizing that for the vertices of greatest depth, $V_l$ and $V_r$ would always be the vertices immediately to the left and right in the set (because of the way the LCAs were added to the set). By removing these vertices from the set, the same would now be the case for the vertices of second greatest depth and so forth. This resulted in the following approach for step 2 of the algorithm:
\begin{enumerate}
	\item For each vertex in the set, add its index number to a set $D_i$ corresponding to its depth.
	\item Create a new set $S$ of length n, where each cell block points to the previous and the subsequent cell. (each cell corresponds to a vertex)
	\item For each number in the depth sets, starting at the one with greatest depth, lookup the corresponding cell $s_i$ in $S$ and update the cells it points to, so that they no longer point to $s_i$, but instead points to each other. ($s_i$ is "removed" from the set).
	\item Cell $s_i$ in $S$ now corresponds to vertex $V$ with index $i$ in $L$. $V_l$ and $V_r$ corresponds to the vertices at the indices pointed to by $s_i$.
\end{enumerate}

\subsection{Computing the induced subtrees of $T_2$}
Now that we can induce a subtree from a set of leaves in linear time, all we need is to find the leaves from which we can induce the subtree $S_i$ of $T_2$, given the subtree $M_i$ of $T_1$. Our approach to this is slightly different from the one explained in \cite{nlogn} \todo{explain why}. First we wanted the names of all leaves to be numbers (from 0 to n-1). This is done when creating the tree structures from the newick files?? which was/is explained in \todo{section/chapter ???}. Second, for each leaf in $T_1$ we wanted it to be possible to find its twin in $T_2$ in constant time. By storing a list for each tree of all its leaves, where each leaf is at the index corresponding to its name, the twin of a leaf named $i$ from $T_1$ can be looked up in constant time from the list for $T_2$ at index $i$.

In order to induce subtree $S_i$, the input leaves needs to be sorted by the order that they appear in $T_2$. Our approach to this was to first compute a sorted list of all leaves in $T_1$, then splitting the leaves into lists corresponding to the subtrees $M_i$, $1 \le i \le p-1$ and finally use their twins to induce the subtree $S_i$ for each list.

Creating a list, where index $i$ holds the position, left to right, of the leaf named $i$ in $T_2$ compared to the other leaves, is done in linear time simply by iterating through $T_2$. That list is used when sorting the leaves of $T_1$ to look up the position of the twins in $T_2$. We sort the leaves in linear time using bucket sort.

By iterating through each subtree $M_i$, we can use linear time to have each leaf store a number corresponding to the subtree to which they belong. Having the sorted list of leaves in $T_1$, we can use the stored numbers to split the leaves into the final lists during a single iteration. Now the twins can be found and the subtrees $S_i$, $1 \le i \le p-1$ can be computed.

All in all this process takes $O(n)$ time.

\section{Matching Graphs}
When having computed the $S_i$ subtrees, the next step is to compute the matching graphs. One graph for each path in the centroid decomposition for $T_2$. Such a graph consists of an amount of edges between two nodes.

Let $x$ be the start node of the centroid path $\pi(x)$ in $T_2$ with side trees $N_j, 1 \le j \le q$. Then the graph $G(x)$ is defined as follows:

\begin{itemize}
	\item $G(x)$ consists of edges between two sets of nodes $L(x)$ and $R(x)$.
	\item $R(x)$ consists of the nodes from $\pi(x)$
	\item $L(x)$ contains nodes from the centroid path $\pi$ in $T_1$, for which there is an edge to some node in $R(x)$.
	\item An edge $(u_i, v_j), 1 \le i \le p-1, 1 \le j \le q$ exists if and only if $S_i \cap N_j \ne \emptyset$
	\item An edge $(u_p, v_j), 1 \le j \le q$ exists if the twin of $u_p$ is in $N_j$.
\end{itemize}

\subsection{Creating the Matching Graphs}
First of all, a graph is created for each centroid path in $T_2$, where all nodes in the path is added to the right set. In order to get access to such a graph in constant time from a node in the path, we will make each start node of the paths point to the corresponding graph.
Since the left set of each graph only contains nodes from $\pi$ we can add these nodes and all edges by doing a walk through $\pi$. This walkthrough contains the following steps for each node $z \in S_i$ for each $u_i \in \pi, 1 \le i \le p-1$:

\begin{enumerate}
	\item Find the corresponding node $z'$ in $T_2$.
	\item If $z'$ is on a centroid path $\pi(z')$ (this is the case if $z'$ has a pointer to the start node of a path), do the following:
	\subitem Find the graph $G(z')$ that corresponds to the path $\pi(z')$. This is done in linear time since $z'$ has a pointer to the start node $start(\pi(z'))$ which has a pointer to the graph.
	\subitem Add $u_i$ to $L(z')$ if it has not already been added.
	\subitem Add an edge between $u_i$ and $z'$ in $G(z')$.
	\subitem Repeat from step 1 using the parent of $start(\pi(z'))$ as node $z$.
	\item If $z'$ is not on a centroid path, repeat from step 1 using the parent of $z$.
\end{enumerate}
The loop stops either when reaching the root of $T_2$ or when reaching a node which is on the same path as the node in $T_2$ that corresponds to the parent of $z$ in $S_i$. The second case means that the rest of the processing has already been done by the parent. This ensures that for each node visited in $T_2$, an edge is added to some graph, meaning that the process of adding all edges takes linear time with respect to the total number of edges in the graphs.

For the last node $u_p$ in $\pi$, the process is very similar. $z$ starts being the twin of $u_p$ and the loop continues until reaching the root of $T_2$.\\

For a node $s$ in a subtree $S_i, 1 \le i \le p-1$, every node $v_j$ visited in the iteration, will be the node that is the closest ancestor of $s$ in some path, which means that either $s \in N_j$ or $s=v_j$. Both cases means that $S_i \cap N_j \ne \emptyset$ so an edge should be added.

\section{Agreement Matchings}
\todo{Describe how to create the agreement matchings}\\
\todo{Describe definitions nsav, ...}

\subsection{The Weighted Search Tree}
For each matching graph $G(x)$, we need to create a weight balanced binary search tree $\mathcal{T}$ from the nodes in $R(x)$. Each node $v_j$ will be a leaf in $\mathcal{T}$ with weight $n_j + \frac{|T(x)|}{nsav(x)}$ if a non-singleton edge in $G(x)$ has endpoint in $v_j$ and weight $n_j$ otherwise.

Such a tree can be constructed in $O(|R(x)|)$ time using the following algorithm which is our version of the algorithm described by \todo{[Mehlhorn (, Fredman)]}.

\begin{itemize}
	\item Given weights ${w_0, w_1, ..., w_{n-1}}$, construct two lists of sums ${L_0, ..., L_{n}}$ and ${R_0, ..., R_{n}}$, where
	\subitem $L_j=\sum_{k=0}^{j-1} w_k$, $L_0=0$
	\subitem $R_j=\sum_{k=j}^{n-1} w_k$, $R_{n}=0$
	\item Construct the tree from weights ${w_0, w_1, ..., w_{n-1}}$ by recursion over the following steps:
	\subitem Given weights ${w_i, ..., w_j}$
	\subitem If $i=j+1$ then create node $j$ with children $i$ and $j$.
	\subitem Otherwise, determine $i<k\le j$ such that
	\subsubitem $L_{k-1} < R_{k-1}$ and $L_k \ge R_k$
	\subitem Define node $k$ with the children created recursively from weights
	\subsubitem ${w_i, ..., w_{k-1}}$ and ${w_k, ..., w_j}$
	\subsubitem If $i=k-1$, the left child is just node $i$
	\subsubitem If $k=j$, the right child is just node $j$
\end{itemize}

Determining $k$ from the weights ${w_i, ..., w_j}$ is done by finding the smallest $k$ satisfying $L_k \ge R_k$. This can be done in time $O(log(k))$ as follows:

\begin{itemize}
	\item For the middle index $k=i+(j-i+1)/2$, determine whether $L_k \ge R_k$
	\item If not, let $k=i+1, k=i+2, k=i+4, k=i+8$ until $L_k \ge R_k$
	\subitem In the interval between $k$ and the previous value of $k$, use binary search to find the smallest $k$ satisfying $L_k \ge R_k$
	\item The case where $L_k \ge R_k$ is treated symmetrically
\end{itemize}

Our implementation of this algorithm was done iteratively, but the approach was the same.






