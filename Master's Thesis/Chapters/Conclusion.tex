\chapter{Conclusion}
\label{ch:conclusion}
The $O(n^2)$ algorithm turned out to be fairly simple to understand and implement, but has its limitations as a result. The algorithm is useful for smaller trees, but falls short otherwise. This is mainly because there seemingly is no way to guarantee that the entire size table won't be kept in memory during construction or backtracking of the size table. Our expectation was originally that this algorithm might outperform the $O(nlog(n))$ algorithm simply because of lesser algorithmic complexity and therefore possibly also overhead. However, that turned out to be false. The two algorithms seemed to perform similarly for trees up to the size of ~500, from which point forward the complexity difference became apparent.
The $O(nlog(n))$ algorithm, which is currently the best theoretical solution to the problem in terms of complexity, took significant effort to implement. It requires some attention to detail when coding, since the complexity is quickly broken by small mistakes. As expected, it performs way better on large trees, and reasonable well on smaller trees also.

\subsection{Future Work}
Given more time, we would have liked to explore the following subjects further.\\

\noindent\textbf{Distances:} the MAST problem can quite easily be used as a measure of distance between two trees. One could just define the distance between two trees as the size difference between the input trees and the produced MAST. However, it could be interesting to see how such a distance measure might relate to other, faster, algorithms for tree distance. \\ 

\noindent\textbf{Multiple Trees:} The MAST problem is defined between two trees, but how, if possible, can one efficiently handle MAST calculated between multiple trees. Given a number of trees, a quick solution is to compute the MAST between the first two trees, prune the appropriate leaves from the next tree in line, and then run the algorithm on the MAST and the next tree in line. This initially gives a complexity of $O(knlogn)$, where k denotes the number of trees. \\   

\noindent\textbf{Non-Binary Trees:} While binary trees are most commonly used, it would be interesting to research how the $O(nlogn)$ algorithm might be expanded for degrees larger than two. The existence of an algorithm with complexity $O(n\sqrt{d}logn)$ for trees of degree d was conjectured in \cite{nlogn}, and was later followed up by \cite{FastMatch}. \\

\noindent\textbf{Memory:} The consumption, allocation and deallocation of memory is a major factor is the $O(nlogn)$ algorithm's running time. As such, we would like to investigate whether any data structures could improve the running time in practice, while the overall complexity stays the same. 
